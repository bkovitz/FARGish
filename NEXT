Demo 3

    Mustang Sally
        Give more weight to promising CouldMakeFromOperands tags.
        Hopefully that will solve more easy problems (without backtracking).

    max_total_support = 100  DONE

    WantFullySourced: huge support
        Hopefully that will favor "wins".  DONE not much effect

    #GettingCloser tag
    Edge weights for "closer"

    TooHigh tag
        Opposition rather than support

    Two CouldMakeFromOperands that share one or more nodes should oppose
    each other.

    HACK: Only one Decision per timestep.

Demo 2

   Mustang Sally

      1 1; 2  with Watchers as nodes
        Make 1+1=2 much more attractive than 1*1=1
            Need still better way of favoring 1+1=2, since the current way
            isn't working.
                support.py
                Consumers vs. Watchers


      default_watchers -> initial_watchers
        Create these nodes in NumboGraph's ctor

      Better logging
        Need to see Datums in FoundWanted and CombineOperands, not just
        node ids.

      1 1 1 1 1; 6  Figure out 2 * 3 = 6
         EquationWatcher
            Hacked with ctor args; internal graph
            Trigger only upon spotting result

   Something top-down
   Minus / Needs operands to be ordered
   120 1 2 3 4; 121   Figure out 120 + 1 = 121 right away  SALLY

Do Response annotations differently: Build should indicate whether it
successfully Built or not.

Don't allow multiple consumers. Or detect it and correct it if it
happens.

   Disallow consumer loops, too!

   Try writing out the current model in English-FARGish.  DONE

Don't allow a Block to consume itself.

Seek(2) and Seek(3) alone should prime the model to solve 1 1 1 1 1; 6.

   Add Consumed tag upon consuming.

   Change Consumed to Avail in cascade_fail.

----------


Main loop:
    Randomly choose a response and execute it


CouldMake
    Make the desired Number by completing the equation.


Support
    Set the edge weight in the unit test.


Bottom-up "noticing"
   
   Notice that 120 is "close to" 121.
      CloseNumbersTagger
      tag: CloseNumbers
      CloseToWantedWatcher
         start a process to build the difference

Top-down "searching"

   Make a Wanted-Block node
   When fulfilled, capitalize. E.g. did we solve the numble?
   Detect failure somehow
   Upon failure, add tags so we don't try that again

   Spreading activation to find equation to complete


Salience

   Let Watchers fade away


Design / Refactoring

   Some sort of "filter" to pass nodes through a series of criteria.
   a Nodes class that knows what graph the nodes come from.


Tools

   Single-stepper for FARG model
