# NodeSpec.py -- Classes that denote nodes to search for

from abc import ABC, abstractmethod
from random import choice
from itertools import product

from util import intersection


class NodeSpec(ABC):
    '''A specification of a condition for nodes to satisfy.'''

    @abstractmethod
    def is_match(self, g, nodeid):
        '''Does nodeid match this NodeSpec?'''
        pass

    def see_all(self, g, nodes=None):
        '''Returns a list of all the nodes in g that satisfy this NodeSpec.
        If nodes is not None, it's a subset of nodes in which to search.'''
        if nodes is None:
            nodes = g.nodes # All nodes: inefficient
        return [n for n in nodes if self.is_match(g, n)]

    def see_one(self, g, nodes=None):
        '''Returns a single node in g that satisfies this NodeSpec, chosen
        randomly if there are more than one, or None. If nodes is not None,
        specifies a subset of nodes in which to search.'''
        ns = self.see_all(g, nodes)
        if ns:
            return choice(ns) #TODO weight choice by salience or other
                              #specified criterion?
        else:
            return None

class NodeOfClass(NodeSpec):

    def __init__(self, nodeclass):
        self.nodeclass = nodeclass

    def is_match(self, g, nodeid):
        return g.is_of_class(nodeid, self.nodeclass)

class NodeWithTag(NodeSpec):

    def __init__(self, nodeclass, tagclass):
        self.nodeclass = nodeclass
        self.tagclass = tagclass

    def is_match(self, g, nodeid):
        return (
            g.is_of_class(nodeid, self.nodeclass)
            and
            g.has_tag(nodeid, self.tagclass)
        )

class NodeWithNeighbor(NodeSpec):

    def __init__(self, port_label):
        self.port_label = port_label

    def is_match(self, g, nodeid):
        return g.neighbor(nodeid, port_label=self.port_label) is not None

class HasSameValue(NodeSpec):
    '''Matches nodes with same value as targetid, but does not match
    targetid.'''

    def __init__(self, targetid):
        self.targetid = targetid

    def is_match(self, g, nodeid):
        if nodeid == self.targetid:
            return False
        return g.value_of(nodeid) == g.value_of(self.targetid)

class And(NodeSpec):

    def __init__(self, *conjuncts):
        '''Conjuncts are NodeSpecs. And(conjuncts) matches nodes that match
        all the conjuncts.'''
        self.conjuncts = conjuncts

    def is_match(self, g, nodeid):
        return all(c.is_match(g, nodeid) for c in self.conjuncts)

class Not(NodeSpec):

    def __init__(self, nodespec):
        self.nodespec = nodespec

    def is_match(self, g, nodeid):
        return not self.nodespec(g, nodeid)

class CartesianProduct:
    '''Specifies criteria for tuples of nodes. Each node in the tuple has its
    own Nodespec, and the whole tuple can have further criteria, e.g. to
    disallow the same node from appearing more than once in one tuple.'''

    def __init__(self, *nodespecs, whole_tuple_criteria=None):
        self.nodespecs = nodespecs
        self.whole_tuple_criteria = whole_tuple_criteria

    def see_all(self, g, nodes=None):
        '''Returns a list of tuples of nodes that meet all the criteria.
        If nodes is not None, it specifies a subset of nodes in which to
        search.'''
        return [
            tup for tup in product(
                *(nodespec.see_all(g, nodes) for nodespec in self.nodespecs)
            ) if all(c(tup) for c in self.whole_tuple_criteria)
        ]

    def see_one(self, g, nodes=None):
        '''Returns one tuple of nodes that meets all the criteria, chosen
        randomly if more than one exists, or None if no such tuple exists.
        If 'nodes' is not None, it specifies a subset of nodes in which to
        search.'''
        ns = self.see_all(g, nodes)
        if ns:
            return choice(ns) # TODO Weight choice by salience or other
                              # specified criteria?
        else:
            return None

class TupleCriterion(ABC):
    '''Specifies a criterion for a tuple of nodes, such as is generated by
    CartesianProduct, must satisfy.'''

    @abstractmethod
    def is_match(self, g, tup):
        '''Returns True iff tup matches the criterion.'''

class NoDups(TupleCriterion):
    '''Allows no nodeid to appear more than once in the tuple.'''

    def is_match(self, g, tup):
        return len(set(tup)) == len(tup)

no_dups = NoDups()

class NotLinkedToSame(TupleCriterion):
    '''Disallows a tuple of nodes where the nodes all link to a single node
    via specified port labels.'''
    def __init__(self, *port_labels):
        self.port_labels = port_labels

    def is_match(self, g, tup):
        '''tup must have same length as self.port_labels.'''
        if len(tup) != len(self.port_labels):
            raise(ValueError(f'tuple {tuple} and port_labels {self.port_labels} do not have the same length.'))
        mate_sets = []
        for nodeid, port_label in tup, self.port_labels:
            mate_sets.append(g.neighbors(nodeid, port_label=port_label))
        common_mates = intersection(*mate_sets)
        return len(common_mates) == 0

class TupAnd(TupleCriterion):

    def __init__(self, tupcriteria):
        self.tupcriteria = tupcriteria

    def is_match(self, g, tup):
        return all(c.is_match(g, tup) for c in self.tupcriteria)
