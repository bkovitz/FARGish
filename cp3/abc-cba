abc -> cba; pqr -> ?
S1     S2   S3     S4


1. Repetition detector:   'abc'
   R1=Repeat(S1, D1, F1)
   D1=Seed(L1, K1)
   L1='a'
   K1=1       a relative address
   F1=Succ

2. Repetition detector:   'cba'
   R2=Repeat(S2, D2, F2)
   D2=Seed(L2, K2)
   L2='c'
   K2=1
   F2=Pred

   This is not so good. We want to perceive the mirror relation. To get that,
   we need the seed to be the same for both repeaters but the direction to be
   opposite.

   If we made an Arrow painter that said "change 'a' to 'c' and Succ to Pred",
   that wouldn't work very well on 'ppqqrr'.

   Should the model, prompted by Succ/Pred, search for a Mirror relation, so
   the seed would be the same or a mirror for both repeaters?

   Another approach: The model could try running a clumsy Arrow painter and
   find that it doesn't work so well on 'ppqqrr'. This requires a modeling
   decision: how does the model judge that Arrow(RR1=repeater('ppqqrr')) was
   clumsy?

   Another approach: Could something in the long-term memory prompt searching
   for a consistent Mirror relationship?

3. 'Same' Detector:
   Q1=Same(I1, J1)
   I1=S1/3
   J1=S2/1
   Leftmost(S2, J1)
   Rightmost(S1, I1)

   Now how does this lead to seeing a mirror relation? The Mirror detector
   has to see this, and maybe at the same time see the Succ/Pred relation.

4. 

X. SOMEHOW construct:
   Arrow(RR1, RR2
   RR1=Repeater(SS1, DD1, FF, .dir=DDR1)
   RR2=Repeater(SS2, DD2, FF, .dir=DDR2)
   OtherSide(SS1, SS2)
   DD1=Seed(LL, KK1)
   LL='a'
   KK1=1
   DD2=Seed(LL, KK2)
   KK2=3
   Opposite(DDR1, DDR2)

   #Add(RR1, RR2, Direction(RightToLeft))

   Arrow(RR1, RR2
   RR1=Repeater(SS1, DD1, FF, .dir=DDR1)
   RR2=Repeater(SS2, DD2, FF, .dir=DDR2)
   OtherSide(SS1, SS2)
   DD1=Seed(LL, KK1)
   DD2=Seed(LL, KK2)
   Opposite(DDR1, DDR2)
   Opposite(KK1, KK2)    <-- how do we determine the opposite of an index?
      Not so good, because relative indices don't know what snippet they're
      part of. So, Opposite can't figure out that 3 is the opposite of 1.

   Could the snippet have direction rather than the repeater? Let's say no,
   because multiple repeaters may need to view the same snippet differently.

   Should relative indices know what painter they're a part of? No. That would
   nbe an absolute index.

   Could we refer to cells by their tags--i.e. use the tags themselves as
   indices?
          aaaaaaataaaaaaaaaaaaaa  TheSalientThing
   Such addressing would work well when moving to a new context. This is true
   "relative addressing". Relative means relative to context. "Index Tags"

   What do index tags look like?

      Rightmost
      Leftmost
        ^ have an Opposite relation

      TheSalientThing
        ^ needs to be relative to the reason for salience?

      a tag for a rough ratio of where something is in its snippet, like
      "in the middle" or "about 1/3 of the way from the left"

      a tag for the flaw in a snippet, e.g. the 'd' in 'abd'

      There must be painters that paint TheSalientThing. This allows
      flexibility in what gets tagged Salient.

      What is Salient might be "what got tagged" (with some other tag).

      What is Salient might be "what didn't get tagged", e.g. the cell or
      snippet that is not Leftmost or Rightmost.  13. kkmmmmooo

      Do we need a salience-detector, analogous to a repetition-detector?
      This would mean that if a painter referred to "WhatIsSalient", the
      salience-detector would look for something to tag as Salient--a letter,
      a snippet, an index. Maybe, for simplicity, only tag indices as salient.

   WANT: If the indices S1/1 and S2/3 are not tagged Leftmost and Rightmost,
   Opposite should fail but trigger a search to set those tags.

   A simple way to achieve that:
      1. Tag Arrow(RR1=R3 'pqr') 'failed' in such a way that allows retrying
         it later. Maybe, "needs index with Opposable tag".
      2. That need boosts the activation of Rightmost and Leftmost.
      3. They wake up and tag S1/1 and S3/3.
      4. Then the model re-runs Arrow and it succeeds. Then the model removes
         the failure tag.

   CONCLUSION: A painter cluster is a new proto-prainter.


   Rightmost and Leftmost are the only possible start (or end) indices for any
   repeater.

   Could the model create the Seed concept dynamically? Two of a repeater's
   arguments are .start_index and .start_letter. Often we need to bundle these
   together, hence the Seed object. But sometimes we don't; sometimes one of
   them is redundant. So, could the model notice an occasion where it helps to
   bundle these, and create something like this:
      Bundle(.start_index, .start_letter)

   'abc'
   Seed(_, 1)
   Seed('a', _)


   exempli gratia

   i.e.   id est

   Id Ego Superego


TEST RUN

abc  ___
S1   S2   

Arrow(RR1=R1):
   RR2=Repeater(OtherSide(S1), Seed('a', ??: 3), Succ, .dir=RightToLeft)

----------

The same should happen without an arrow, e.g. 'abccba'.
