permaculture


Bjarne Stroustrup's recommended languages: Java, C++, Python, Scheme, ??

unify(I, J)
unify(J, 2)
what is I? 2

unify(f[I, J], f[4, 6])
what is I? 4
what is J? 6


What to do today?
1. Fix bug in painter-creation.  DONE
2. Implement matchcount.  DONE
3. Implement Inside and FilledWith; generate p2 and p4. DONE
4. Run p2 and p4.
5. Figure out how to make p5


1. Ask the Predicate to step through left_substs and right_substs.
2. Make the Painter know its principal arguments, and have code that steps
differently according to the type of the principal argument.

------------------------------------------------------------------------

'____a___a___'

p1a
  Apart[D=4, I=5, J=9]
  Same[I, J]

  Apart.spec_left_to_right(c, {D=2, I=1}) -> {D=2, I=1, J=3})

p2   must hold some record that P=p1a in the original situation
  Inside[P, K]
  FilledWith[K, 'j']

Running p2 yields:

  Given P=p1a(I=5, J=9), what should K be?

  Inside[P=p1a] spec_left_to_right yields:

    K=6   
    K=7
    K=8

  FilledWith, for each of those values of K, yields:

    K=6   PaintAt(6), PaintValue('j')
    K=7   PaintAt(7), PaintValue('j')
    K=8   PaintAt(8), PaintValue('j')


'___j__'

Running p2 yields:

    Given K=4, what should P be? Must return an ActionSpec indicating:
        
        P=p1a I=2 J=6
        P=p1a I=1 J=5

NEXT problem to solve:

Two ways to find all the values of K:
1. spec_left_to_right() loops through K, and returns multiple ActionSpecs.
2. The caller of spec_left_to_right() loops through all values of K, and
   spec_left_to_right() only checks the values in the current Subst.


Hypothetically:
Inside      returns specA, specB       
FilledWith  returns specFA, specFB

Fhould we get 4 PainterActions?
    specA specFA
    specA specFB
    specB specFA
    specB specFB
Or should we get 2 PainterActions?
    specA specFA
    specB specFB

WANT

    for su in all_substs(ws, all_predicates):
        for predicate in predicates:
            tu = su
            specs = set()
            for tu, spec in predicate.spec_left_to_right(ws, su):
                specs.add(spec)

    for su in all_substs(ws, all_predicates):  # <-- new idea, look at all
                                               # predicates at once
        for predicate in predicates:
            match spec_left_to_right(ws, su):
                case ActionSpec():

    (all_predicates, su) -> ActionSpecs
                    
