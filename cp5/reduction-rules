The official, complete set of rewrite rules as of 5-May-2023

Variable types:

C : a canvas
I : an index
(I+1) : an index equal to I+1; (expr) matches rather than reduces
L : a letter
Succ(L) : a letter equal to Succ(L)
R : a repeater
E : an exception, i.e. Skip(I)
CANVAS_RELATION : OtherSide
DETPAINTER[A B] : a painter with A and B among its arguments:
   AddExceptionPainter, CanvasLengthPainter, CombinedPainter, Same
N : an integer, such as a canvas length
C.x : x is a label for anything inside a canvas: a cell (labeled by an index), a length, a side, a tag.

Terms:

C.I=L  AtCell[canvas index letter]
C.len=N  CanvasLength[canvas length]  AtCell[canvas 'len' length]
Seq[canvas operation start-index end-index start-letter end-letter]
SeqSkip[canvas operation start-index, end-index start-letter end-letter skip-index]
Repeat[canvas start-letter operation]
Repeat[canvas start-letter operation exception]
Skip[relative-index]
OtherSide[left-canvas right-canvas]
AddExceptionPainter[canvas-relation exception; repeater1 repeater2 canvas1 canvas2]
Same[cell1 cell2]
CanvasLengthPainter[canvas1 canvas2 operation canvas-relation]
CombinedPainter[painter1 painter2]  Do we need determinate arguments, too?


Rules:

C.I=L, C.(I+1)=Succ(L) -> Seq[C Succ I I+1 L Succ(L)]
   ; From two consecutive letters, build a Seq
C.I1=L1, Seq[C Succ (I1+1) I2 Succ(L1) L2] -> Seq[C Succ I1 I2 L1 L2]
   ; Prepend a letter to a Seq
Seq[C Succ I1 I2 L1 L2], C.I2+1=Succ(L2) -> Seq[C Succ I1 I2+1 L1 Succ(L2)]
   ; Append a letter to a Seq
Seq[C Succ I1 I2 L1 L2], Seq[C Succ (I2+1) I3 Succ(L2) L3] -> Seq[C Succ I1 I3 L1 L3]
   ; Append one Seq to another (no overlap)
Seq[C Succ I1 I2 L1 L2], Seq[C Succ I2 I3 L2 L3] -> Seq[C Succ I1 I3 L1 L3]
   ; Append one Seq to another (overlap on one letter)
Seq[C Succ 1 C.last L L2] -> Repeat[C L Succ]
   ; A Seq that fills a whole canvas becomes a Repeat

Seq[C Succ I1 I2 L1 L2], C.(I2+1)=Succ(Succ(L2)) -> SeqSkip[C Succ I1 (I2+1) L1 Succ(Succ(L2)) (I2+1)]
   ; Next letter after Seq skips one in the sequence
C.I=L, C.(I+1)=Succ(Succ(L)) -> SeqSkip[C Succ I (I+1) L Succ(Succ(L)) (I+1)]
   ; Double Succ in consecutive cells makes a SeqSkip
C.I=L, SeqSkip[C Succ (I+1) I2 Succ(L) L2 ISKIP] -> SeqSkip[C Succ I I2 L L2 ISKIP]
   ; Prepend letter to SeqSkip
SeqSkip[C Succ I1 I2 L1 L2 ISKIP], C.(I2+1)=Succ(L2) -> SeqSkip[C Succ I1 (I2+1) L1 Succ(L2) ISKIP]
   ; Append letter to SeqSkip
Seq[C Succ I1 I2 L1 L2], SeqSkip[C Succ (I2+1) I3 Succ(L2) L3 ISKIP] -> SeqSkip[C Succ I1 I3 L1 L3 ISKIP]
   ; Prepend Seq to SeqSkip
SeqSkip[C Succ I1 I2 L1 L2 ISKIP], Seq[C Succ (I+1) I3 Succ(L2) L3] -> SeqSkip[C Succ I1 I3 L1 L3 ISKIP]
   ; Append Seq to SeqSkip
SeqSkip[C Succ 1 C.last L L2 ISKIP] -> Repeat[C L Succ Skip[ISKIP]]
   ; A SeqSkip that fills a whole canvas becomes a Repeat

C1.side=lhs, C2.side=rhs -> OtherSide[C1, C2]
C1.side=lhs, C2.side=rhs, C1.world=W, C2.world=W -> OtherSide[C1, C2]

Repeat[C1 L Succ], Repeat[C2 L Succ E], CANVAS_RELATION[C1, C2] ->
      AddExceptionPainter[CANVAS_RELATION, E; Repeat[C1 I L Succ], Repeat[C2 I L Succ E], C1, C2)]
   ; A painter that is the functional equivalent of this cluster:
   ;  Cluster(R1, R2; C1, C2)/R1=r1,R2=r2,C1=c1,C2=c2
   ;     AddException(R1, R2, E)
   ;     CANVAS_RELATION(C1, C2)

Same[C1.len=N1, C2.len=N2], CANVAS_RELATION[C1, C2] -> CanvasLengthPainter[C1, C2, Same, CANVAS_RELATION]
   ; A painter to fill in the length of one canvas given a relation with another:
   ;  Cluster(N1, N2; C1.len, C2.len)/C1=c1,C2=c2
   ;  Cluster(LEN1, LEN2; C1, C2)/C1=c1,C2=c2
   ;     Same(LEN1, LEN2)
   ;     CANVAS_RELATION(C1, C2)

AddExceptionPainter[CANVAS_RELATION1, E, R1, R2, C1, C2], CanvasLengthPainter[C1, C2, CANVAS_RELATION2] ->
      CombinedPainter[
         AddExceptionPainter[CANVAS_RELATION1, E, R1, R2, C1, C2],
         CanvasLengthPainter[C1, C2, CANVAS_RELATION2]
      ]
   ; A painter that combines two painters, like this:
   ;  ClusterCluster[
   ;     ClusterAddException[CANVAS_RELATION1, E, R1, R2, C1, C2],
   ;     ClusterCanvasLength[C1, C2, CANVAS_RELATION2]
   ;  ]

DETPAINTER[C1, C2], CANVAS_RELATION[C1, C2], CANVAS_RELATION[C3, C4] -> DETPAINTER[C3, C4]
   ; When a new determinate painter could paint at a new location, create a variant of that painter with
   ; the new location for its args.



C1.1='a'
C1.1='b'

Seq[C Succ I1 I2 L1 L2]  <-- lhs of a rule
Seq[c1 Succ 1 c1.last 'a' 'c']  <-- an Item; nothing to evaluate
C=c1 I1=1 I2=c1.last L1='a' L2='c'  <-- substitution returned by unifying lhs with Item


FUTURE:

OP : Succ, Pred, or Same ?

Some way to "jump to a conclusion" about a sequence, assuming regularity wher
it's not present, e.g. abcdefgijklmno  
